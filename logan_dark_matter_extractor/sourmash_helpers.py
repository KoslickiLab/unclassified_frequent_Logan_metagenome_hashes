"""
Sourmash-compatible hashing and k-mer extraction helpers.

We default to using the sourmash CLI 'signature kmers' to *extract only those*
k-mers that belong to an accession's sketch (massive speedup).
We also provide a Python iterator that computes (k-mer, hashval) when CLI
is not available or a signature isn't provided.

References:
- DNA hashing uses 64-bit MurmurHash with seed=42 on canonical k-mers.
- FracMinHash keeps hashes < 2**64 / scaled.
- 'sourmash signature kmers' emits matching k-mers and their hash values.
"""

from __future__ import annotations
from pathlib import Path
import csv
import subprocess
import shutil
from typing import Iterable, Iterator, Tuple, Optional

from .log import get_logger
from .config import K, SCALED, MAX_HASH

LOGGER = get_logger("sourmash_helpers")

def have_sourmash_cli() -> bool:
    return shutil.which("sourmash") is not None

def run_sig_kmers(signature_zip: Path,
                  fasta_path: Path,
                  out_csv: Path,
                  k: int = K,
                  overwrite: bool = False) -> Path:
    """
    Run `sourmash signature kmers` and write CSV with columns that include at least:
    filename, sequence_name, kmer, hashval, position (column names may vary slightly per version).
    """
    if out_csv.exists() and not overwrite:
        LOGGER.info("Reusing existing kmer CSV: %s", out_csv)
        return out_csv

    cmd = [
        "sourmash", "signature", "kmers",
        "--signatures", str(signature_zip),
        "--sequences", str(fasta_path),
        "--ksize", str(k),
        "--save-kmers", str(out_csv),
    ]
    LOGGER.info("Running: %s", " ".join(cmd))
    subprocess.run(cmd, check=True)
    return out_csv

def iter_sig_kmers_hashes(csv_path: Path) -> Iterator[Tuple[str, int]]:
    """
    Stream parser for 'kmer-matches.csv' generated by sourmash signature kmers.
    Yields (sequence_name, hashval) pairs.

    We remain tolerant to small header variations across sourmash versions.
    """
    with csv_path.open("r", newline="") as f:
        reader = csv.DictReader(f)
        # Try common header variants
        seq_col = None
        for candidate in ("sequence_name", "name", "sequence", "seqname"):
            if candidate in reader.fieldnames:
                seq_col = candidate
                break
        if seq_col is None:
            raise RuntimeError(f"Could not find a contig name column in {reader.fieldnames}")
        hash_col = "hashval" if "hashval" in reader.fieldnames else "hash"
        if hash_col not in reader.fieldnames:
            raise RuntimeError(f"Could not find a hash column in {reader.fieldnames}")

        for row in reader:
            try:
                seqname = row[seq_col]
                h = int(row[hash_col])
            except Exception as e:
                LOGGER.warning("Skipping malformed row: %s (%s)", row, e)
                continue
            # guard for scaled=1000
            if 0 <= h < MAX_HASH:
                yield (seqname, h)

def iter_hashes_python(sequence: str,
                       k: int = K) -> Iterator[int]:
    """
    Fallback iterator: compute sourmash-compatible hash for each k-mer in 'sequence'.

    Uses sourmash.MinHash(...).kmers_and_hashes with scaled=1 just to retrieve hashes,
    and then we apply the MAX_HASH gate for scaled=1000.
    """
    import sourmash
    mh = sourmash.MinHash(n=0, ksize=k, scaled=SCALED)  # scaled=1 -> all k-mers
    for _kmer, h in mh.kmers_and_hashes(sequence, force=True):
        if 0 <= h < MAX_HASH:
            yield h
        # TODO: depending on how this is used, might also want to return the k-mer itself
